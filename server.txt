#
# This is the server logic of a Shiny web application. You can run the
# application by clicking 'Run App' above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#

library(shiny)
library(readxl)
# Define server logic required to draw a histogram
function(input, output) {
    
    #values=reactiveValues(data1=0 ,data2=0)
    #observeEvent(input$values, {values$data1=1})
    
    #observeEvent(input$values, {values$data2=1})
    # Read data
    csvfile <- reactive({
        req(input$file1)
        df <- read.csv(input$file1$datapath,header=TRUE , fileEncoding = "UTF-8")
        return(df)
    })
    
    values <- reactiveValues(inDir = NULL)
    observeEvent(input$do_it, {values$inDir <- csvfile()})
    observeEvent(input$do, {values$inDir <- read.csv("./test123.csv", header=TRUE, fileEncoding = "UTF-8")})
    observeEvent(input$delete, {values$inDir <- NULL })
    DATA <- eventReactive(values$inDir, {values$inDir})
    
    # set uploaded file
    output$table <- renderDT({
        inFile <- DATA()
    })
    
    # 圖表呈現涵式
    output$scatter <- renderPlot({
        data1 <- DATA()
        plot(data1)
    })
    output$summaryDset <- renderPrint({
        data2 <- DATA()
        summary(data2)
    })
    output$boxplot <- renderPlot({
        data3 <- DATA()
        boxplot(data3)
    })
    output$histogram1 <- renderPlot({
        data4 <- DATA()
        data4=as.matrix(data4)
        barplot(table(data4), main = "Count Number", xlab = "Ball Number", 
                ylab = "Frequency", col = rainbow(11))
    })
    output$ttest <- renderPrint({
        data5 <- DATA()
        t.test(data5, mu = 4.5, alternative = 'greater')
    })
    output$histogram5 <- renderPlot({
        data6 <- DATA()
        data6=as.matrix(data6)
        y_m <- melt(data6)
        histogram(x= ~ value | Var2,data=y_m, xlab="Number",layout=c(5,1))  # 以5x1的方式呈現圖表
    })
    
    ###############################################################
    #爬蟲
    worddata <- reactive({
        url <- "https://1958a.com/forum-71-1.html"
        doc <- read_html(url, encoding = "UTF-8")
        header <- doc %>% html_nodes(".xstt") %>% html_text()
        mixseg = worker()
        test=mixseg[header]
        test1=table(test)
        worddataframe=as.data.frame(test1)
        colnames(worddataframe) <- c("Word", "Freq")
        #deletnumber=!is.na(as.numeric(worddataframe$Word))
        #worddataframe2=worddataframe[deletnumber==FALSE,]
        return(worddataframe)
    })
    
    #文字雲
    output$wordcloud1 <- renderWordcloud2({
        test1 <- worddata()
        wordcloud2(test1 , fontFamily ='微軟雅黑',  
                   color = 'random-light', backgroundColor = 'grey') 
        
    } )
    
    #直方圖
    output$histword1 <- renderPlot({
        test2 <- worddata()
        subset(test2, Freq>10) %>%
            ggplot( aes(Word , Freq)) +
            geom_bar(stat="identity", fill="darkred", colour="darkgreen") #+
            #theme(axis.text.x=element_text(family="wqy-microhei",angle=45, hjust=1))
        
    })
    
    #樹狀圖
    output$treemap <- renderPlot({
        test3 <- worddata()
        test3$Word<-as.factor(test3$Word)
        subset(test3, Freq>10) %>% ggplot(aes(area=Freq,fill=Word,label=Word))+
            geom_treemap()+geom_treemap_text(fontface='italic',place='centre')#+
            #theme(axis.text.x=element_text(family="wqy-microhei"))
        
    })
    
    
    ##################################################################
    #异常侦测
    abdata <- reactive({
        btc <- get_historic_price(start = "2019-01-01")
        btc_ts <- btc %>% rownames_to_column() %>% as.tibble() %>% 
            mutate(date = as.Date(rowname)) %>% select(-one_of('rowname'))
        return(btc_ts)
    })
    
    output$timeseries <- renderPlot({
        btc_ts=abdata()
        btc_ts %>% 
            time_decompose(Price, method = "stl", frequency = "auto", trend = "auto") %>%
            anomalize(remainder, method = "gesd", alpha = 0.05, max_anoms = 0.2) %>%
            plot_anomaly_decomposition()
    })
    
    output$anomalydetection <- renderPlot({
        btc_ts=abdata()
        btc_ts %>% 
            time_decompose(Price) %>%
            anomalize(remainder) %>%
            time_recompose() %>%
            plot_anomalies(time_recomposed = TRUE, ncol = 3, alpha_dots = 0.5)
    })
    
}
